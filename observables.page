---
categories: programming scala reactive_programming rx
...

An asynchronous version of `Iterable`, similarly to how `Future` is an asynchronous version of `Try`.

~~~ {.scala}
trait Observable[T] {
  def subscribe(observe: Observer[T]): Subscription
}

trait Observer[T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def onCompleted(): Unit
}

trait Subscription {
  def unsubscribe(): Unit
}

~~~

## Composition

### `flatten`

~~~ {.scala}
def flatten: Observable[Observable[T]] => Observable[T]
~~~

Merges nested observables on first-come-firs-served basis -- i.e. can result in reordering the top-level observable.

### `concat`

~~~ {.scala}
def concat: Observable[Observable[T]] => Observable[T]
~~~

Concatenates nested observables preserving the order of top-level observable. The downside is that it might need to buffer potentially unbounded prefixes of observables that are further down in the top level sequence, if they produce results quicker than the first observable.

## References

* Reactive Programming Coursera courese [lecture](https://class.coursera.org/reactive-001/lecture/61)