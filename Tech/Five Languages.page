---
title: Five Languages
categories: blog it programming_languages
...

<img src="rosetta_tweet.png" alt="@rosettacode: Pick three to five programming languages for teaching orthogonal programming paradigms. Which did you choose? Why? Blog and I'll share." />

Interesting you should ask that, Rosetta Code. I've been pondering similar questions before, most recently inspired by Bruce Tate's _[Seven Languages in Seven Weeks](http://pragprog.com/book/btlang/seven-languages-in-seven-weeks)_, whose languages of choice were sometimes overlapping (e.g. Io and Ruby) while leaving certain areas, such as concatenative languages, unexplored. What languages would I have chosen? 

Let's start with the paradigms. It's not a very clear term; is object orientation a paradigm or just a technique that can be applied to programs written in both imperative and declarative style? Is _imperative programming_ a paradigm? If so, what is _procedural programming_? The orthogonality requirement complicates things further. Functional programming is not orthogonal to procedural programming, but OO is to both, so how do we choose which features to represent? We are going to just gloss over these formal problems and arbitrarily select five diverse families of programming languages:

* imperative
* functional
* object-oriented
* logic
* Lisp-like

What languages should represent them? Given the limit of five languages, it might seem that multi-paradigm ones suche as C++, Oz or Scala would offer the biggest bang for the buck. However, given that the purpose is _teaching_, we will be better off with smaller languages; ideas can be better appreciated and internalised when presented in a context of a language that was specifically designed around them. So, the our criteria for choice will be:

* size - both conceptual and syntactical; the smaller, the better, since can be learned faster
* "there is only one way" -- a paradigm or feature is represented clearly, preferably in its pure form
* representative: contain constructs that are commonly found in other languages representing the same paradigm
* practical: the language is used in the "real world", there exists a community, tutorials, libraries and other resources
* influential: other languages have been designed after features introduced first in this language

## Imperative

The way contemparary computers work is inherently imperative: code is simply a list of instructions for the CPU. It therefore is fitting to pick for the representative of imperative family a language that makes this connection tangible -- a low-level, systems programming language such as **C**. C is perhaps better known for its [obfuscability](http://ioccc.org) than for the didactic virtues, but appears to match our criteria fairly well: it is small, doesn't support any other style than imperative, has a huge codebase written in it and its syntax influenced most of todays mainstream languages. Studends learning C will be exposed to:

* manual memory management
* pointers and pointer arithmetic
* control flow instructions

Contenders: Assembly, Pascal, Python

## Functional

Since we are aiming for paradigmatic purity and try to avoid obscurity, **Haskell** is a natural choice. Syntactic sugar notwithstanding, the core is very small and can be boiled down to lambda abstraction and function application. It provides excellent platform to explain concepts such as

* lambda calculus
* laziness
* strong typing
* type inference
* side-effect isolation
* tail call optimisation
* REPL

Contenders: StandardML, OCaml or Common Lisp and Clojure, if we didn't have a separate category for them

## Object-oriented

TODO
**Smalltalk**
* class hierarchy
* unityped 
* image-based development environment
contenders: Python, Io, Eiffel, Javascript

## Logic

TODO
**Prolog**
* term unification
Contenders: none

## Lisp-like

Lisp-likeness is not a paradigm by a long shot; Lisp is usually considered a functional language, and we have already covered this paradigm. The temptation to instead include a concatenative language was high, but the historical importance and influentiality of Forth pales in comparison with Lisp. Lisp, with its homoiconicity, flexible (some say non-existent) syntax and macro system is a platform of choice for many programming language researchers for a reason. From the countless dialects that mushroomed over the years we will pick **Clojure**, since beside being a modern language with strong and growing community it will also expose our students to one of the major contemporary runtime platforms -- the Java Virtual Machine. So, here's what they will learn about:

* abstract syntax trees
* macros
* homoiconicity
* continuations
* REPL
* JVM
* software transactional memory

Contenders: Common Lisp, and Factor or Forth -- if we went for concatenative instead.

## What is missing?

A lot, obviously, especially in the more exotic end of paradigm spectrum, such as concatenative or array-based languages. It would have been nice to include at least one language with advanced module system (e.g. Standard ML) to demonstrate features that help to build programs in-the-large. That said, we managed to cover an impressive list of features and someone who learns these five languages in reasonable depth can definitely be called a programming erudite.
