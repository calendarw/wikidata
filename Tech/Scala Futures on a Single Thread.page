Synchronous Dataflow with Scala Futures

[Futures](http://docs.scala-lang.org/sips/pending/futures-promises.html), introduced into Scala standard library in version 2.10, quickly became one of the cornerstones of Scala concurrency. Their main selling point is the ease of composition. A standard example of that involves asynchronous calls to a number of remote services and computation of the answer once all of the responses are collected:

~~~ {.scala}
def price(itemId: Id): Future[Price] = ???

def availability(itemId: Id): Future[Int] = ???

def orderQuote(itemId: Id, quantityRequired: Int): Future[Option[Price]] = for {
  unitPrice         <- price(itemId)
  quantityAvailable <- availability(itemId)
} yield if (quantityAvailable >= quantityRequired) Some(quantityRequired * unitPrice) else None
~~~

Here `price` and `availability` are service calls that can potentially take long time and are meant to be executed in parallel.

However, the usefulness of futures is not restricted to a concurrent setting. They also provide a nice pattern for suspending execution of a sequential algorithm until a certain condition is met. There is nothing inherently concurrent about future implementation either -- the runtime behaviour depends on the instance of [`ExecutionContext`](http://www.scala-lang.org/api/current/index.html#scala.concurrent.ExecutionContext) provided to functions that can spawn new computations.

~~~ {.scala}
import scala.concurrent._
import scala.util.{Success, Failure}
import java.util.concurrent.Executor
import scala.collection.mutable
 
implicit val synchronousExecutionContext = ExecutionContext.fromExecutor(new Executor {
  def execute(task: Runnable) = task.run()
})
 
object priceService {
  val prices = mutable.HashMap[String, Int]()
  val pendingRequests = mutable.HashMap[String, Set[Promise[Int]]]() withDefaultValue Set()
 
  def setPrice(symbol: String, price: Int): Unit = {
    prices += (symbol -> price)
    println(s"${Thread.currentThread.getName}: price received: $symbol: $price")
    pendingRequests(symbol).foreach(_.success(price))
  }
 
  def price(symbol: String): Future[Int] = 
    if (prices.contains(symbol)) Future.successful(prices(symbol))
    else {
      val request = Promise[Int]()
      if (pendingRequests.contains(symbol)) pendingRequests += (symbol -> (pendingRequests(symbol) + request))
      else                                  pendingRequests += (symbol -> Set(request))
      request.future
    }
}
 
def publishValuation(symbol: String, quantity: Int): Unit = 
  priceService.price(symbol).map(_ * quantity).onComplete {
    case Success(value) => println(s"${Thread.currentThread.getName}: $quantity x $symbol: $value)")
    case Failure(e)     => println(s"error: $e")
  }
 
priceService.setPrice("AAA", 1013)
publishValuation("AAA", 20)
publishValuation("BBB", 30)
priceService.setPrice("BBB", 221)
~~~