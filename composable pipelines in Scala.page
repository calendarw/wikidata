---
categories: it scala
...

a talk by Philipp Haller about Futures, Promises and Try.

~~~ {.scala}
val avgRetweet twts.map(_.retweets).reduce(_ + _) / twts.length
~~~

* How do we deal in exceptions in this sequence of method calls?
* How do we deal with asynchronicity?
* How do we make it parallel? (this we won't discuss)

## Exception handling

`scala.util.Try` is a simple data container which is composable and provides comibnators for exceptions. Traditionally we used `try ... catch ... finally`, which is installed on the stack as opposed to being first-class values. Scala allows to install custom partial function in `catch`, which helps with code reuser somewhat. `Try` allows us to handle exceptions in completely different context, e.g. in another thread.

~~~ {.scala}
sealed abstract class Try[+T]

final case class Success[+T](value: T) extends Try[T]
final case class Failure[+T](exception: Throwable) extends Try[T]
~~~

_Aside: having sealed abstract class helps the compiler check for exhaustivity of pattern matching._

It provides `Option`-like methods:

~~~ {.scala}
def get: T // returns value or throws exception
def getOrElse[U >: T](default: => U): U
def orElse[U >: T](default: => Try[U]): Try[U]
def map[U](f: T => U): Try[U]
def flatMap[U](f: T => Try[U]): Try[U]
def filter(p: T => Boolean): Try[T] // returns this or Failure if predicate is not satisfied
~~~

What about `Throwables` that should cause a shutdown of JVM (OOM etc.)? These are not caught.

What can we do with `Try`?

~~~ {.scala}
// "catch block" that provides value in place of Failure:
def recover[U >: T](f: PartialFunction[Throwable, U]): Try[U]
~~~

## Asynchronicity



## Execution Contexts