* rrived at 9am, early enough to grab a seat at the front, next to power sockets -- front left.
* Met: Channing and Lance Walton, David Pollak, Adam Fisher

## Adventures with Types in Haskell

*Simon Peyton Jones*

* FPComplete School of haskell plug
* Reasons for Haskell popularity: purity, simple model (lambda calculus), **rich type system**
* Why we want types: catch certain classes of bugs, provide partial specification (e.g. `reverse :: [a] -> [a]`), express design, support interactive development (e.g. intellisense), **ease program maintenance** (e.g. pervasive changes in GHC, SPJ has confidence in making them because of type checks)
* look up: F# type providers, great example of how types help
* how types are bad: get in your way:

~~~ {.haskell}
data IntList = Nil | Cons Int IntList

lengthI :: IntList -> Int
~~~

now, what if we wanted to have length for list of chars? We need a more sophisticated type system (generics).

programs accepted by the language / programs that work -- we want as much overlap between these two sets as possible.

History:

* 1960s: Simple Types
* 1970s: ML with parametric polymorphism
* 1980s: plateau
* 1990s: Haskell: type classes, then plateau
* 2000s: GADTs, then plateau
* recent years: explosion of innovation, crazy type systems

SPJ will be saying a little about a lot of different type system features.

Plan for world domination: build on static typs so that mor good programs are accepted without killing the joy of programming

### Type classes

functions that are nearly polymorphic:

~~~ {.haskell}
sort :: [a] -> [a]
(+) :: a -> a -> a 
~~~

we don't want these functions to be baked into the runtime, specific for every type they operate on (that's what Java does). Solution: **type classes**,

~~~ {.haskell}
(+) :: Num a => a -> a -> a
~~~

### Higher kinds

~~~ {.haskell}
mapL :: (a -> b) -> [a] -> [b]
-- recursive
mapT :: (a -> b) -> Tree a -> Tree b
-- recursive
mapM :: (a -> b) -> Maybe a -> Maybe b
-- non-recursive
~~~

There is a commmon pattern here. How do we unify the API?

~~~ {.haskell}
class Functor k where
  fmap :: (a -> b) -> k a -> k b

instance Functor Maybe where
  fmap f x = mapM f x
~~~

Note: `k` ranges over not types, but type constructors; it has kind `* -> *` (anything of kind `* -> ...` is higher-kinded). This gives as access to whole new level of code reuse:

~~~ {.haskell}
sequence :: Monad m -> [m a] -> m [a]
~~~

This will work for anthing that is in `Monad` class.

Q: can type-level functions be written in ML?
A: using ML module syste to model higher-kinded types is like using a nuclear weapon to open a matchbox -- it works, but there is a lot of collateral damage.

Note: higher-kinded type variables are much harder in languages with subtyping (e.g. OO) because of _variance_.

GHC allows to specify kind signatures: `data Tree (x :: * -> *) (a :: *) = ...`.

Haskell attempts to reuse the intuitions from the term/type level one level up, with types/kinds -- e.g. querying for type (`:t`) and kind (`:k`) in GHCi.

Omega has infinite tower of universes (terms/types/kinds/sorts/level 5/level 6/...)

### GADTs

Idea: allow arbitrary return type for constructors, provided the outermost type constructor of type returned is still the type being defined.

~~~ {.haskell}
data Maybe a = Nothing | Just a
~~~

is the same as

~~~ {.haskell}
data Maybe a where
  Just :: a -> Maybe a
  Nothing :: Maube a
~~~

Classic example of usefulness: term evaluator (same as in [Advanced Haskell]()).

~~~ {.haskell}
data Term a where
  Lit :: Int - Term Int
  Succ :: Term Int -> Term Int
  IsZero :: Term Int -> Term Bool
~~~

Real-life story: stream-processing library Yampa needed to treat identity in a special way. Allowing to express that in type system made huge performance difference

### Type Functions

(a.k.a "type families")

~~~ {.haskell}
class Num a where
  (+) :: a -> a -> a
~~~

what if we want:

~~~ {.haskell}
class GNum a b where
  (+) :: a -> b -> ???

instance GNum Int Int where ...
instance GNum Int Float where ...
~~~

What do we put in place of `???`?

Given `a` and `b` we can tell what `???` should be. 

~~~ {.haskell}
class GNum a b where
  type SumTy a b :: * -- type-level function
  (+) :: a -> b -. SumTy a b

instance GNum Int Int where
  type SumTy Int Int = Int
  ...
~~~

### Kind polymorphism

No time to explain in detail.

~~~ {.haskell}
data T f a = MkT (f a)
~~~

f can be `* -> *` and a `*`
but it can also be `(* -> *) -> *` and `* -> *`

This is the same as `lengthInt` and `lengthChar` at the beginning. we want `T :: \forall k (k -> *) -> k -> *`

Ulitmate goal: **enable programmers to say what they mean**. Simple type systems really do get in our way. We need systems which are sophisticated enough to enable us to say what we mean while staying simple enough to be usable.

### Q/A

Q: Has every experiment that was added to Haskell stayed there?

A: In practice most of them stayed; there is one or two (linear something?) which proved wrong and were removed.

## Across Time and Address Space: Lift 3.0

*David Pollak*

* Lift: developer centric/designer friendly
* most web frameworks are abstractions on top of HTTP request/response
* but developers think about putting buttons on pages, not HTTP
* interactivity is at the core: lift abstracts away the HTTP part of AJAX calls
* templating: DOM manipulation (functions `DOM => DOM`) instead of spitting out strings. This approach has later been used (cloned) in templating systems for Haskell, Java and JavaScript.
* designers and coders share the codebase; designers provide template, developers annotate them with `data-lift` transformations
* best Comet (server push) and Ajax support in the industry; client that disconnects and reconnects gets deltas (in order)
* current Comet implementation is over long polling, but it could be transparently ported to websockets
* automatic deduplication of Ajax requests (eg. on retry after timeout)
* seamless security
* DOM transformations can be done in parallel (e.g. when assembling parts of pages from different sources)
* asynchronous loading of page fragments
* 2.5 is about to be released, then 2.6
* 3.0 will be breaking
* goals for 3.0: move up market, down market, address time and space
* best futures in Scala-land -- EPFL's implementation is not always up to scratch (according to DPP Akka futures implementation sucks)
* markdown templating
* sources easier to understand for non-scala developers -- bindings can be in templates, not in scala sources
* seamless development cycle: changes in sources picked up dynamically, better than with JRebel, which barfs eg. when interface types of anonymous functions change
* server-side javascript data sources (controversial idea):

~~~ {.html}
  <li data-jssource="* *+ #> ['fpx', 2, 'dog', 'hi']">Thing: </li>
~~~

this will generate a list of four elements on the page.

* cross-HTTP actors: requests from page are serialised as JSON and sent to server-side actors -- and vice versa
* Q&A: DPP: he tried to agree on a common Actor interface with Jonas and EPFL but they thought they are smarter so they parted ways.

## Elnode: The Evented IO Web Server

*Nic Ferrier*

Microservices: reaction to heavyweight containers like JBoss. Tiny, little, usually restful services, put together they form SOA.

### Emacs

When Richard Stallman stepped down from being the maintainer of Emacs a number of things happened:

* packages: `M-x package-install somepackage` -- allows pulling packages from outside of FSF, lowers barriers to entry
* server sockets:

~~~ {.lisp}
(defun example-make-server (port)
  "Make listenign socket"
  (let ((buf (get-buffer-create "*example-server*")))
    (make-network-process
     :name "" : buffer buf :server t :nowait 't ...)))
~~~

How does it work without threads (Emacs can't do threads)? Callbacks.

* lexical scope -- it was missing for a long time (thanks to RMS, who was very conservative), but it was introduced in 24; enabled on per-file basis.

### elnode

* a webserver framework in Emacs lisp.
* demo: web server started, but Emacs crashed
* chat demo: works well

### Problems

Why have reprogrammable systems (e.g. Smalltalk) failed? Transactional change? How do we change our running system incrementally? Similar problem to continuous delivery with transactional databases.

### Concurrency

Threads are coming to Emacs (although still with GIL). It would be nice to have actor-based model, it's very similar to microservice idea. Actually, a restricted actor system can be built on top of elnode.


## Comparing Scala and Clojure

*Robert Rees*

* Robert set up London Clojurians group and works on Java/Scala codebase at Guardian

Clojure                  Scala
---------                -------------
lisp with Java interop   Java++
evolving slowly          trying to define itself
simple                   complex
practical                academic
hippie                   enterprise
dynamic                  static

### Typing

* clojure has strong, but primitive types
* why do we need types if we have a test suite?

### Simplicity/Complexity

* Scala has lots of ways in the library to achieve the same result (`reduceLeft`, `foldLeft`, `maxBy`...)
* Scala doesn't aim to be complex; Clojure strives to be simple

### Enterprise

Clojure                  Scala
---------                -------------
no objects               data model like in Java
poor tooling             good tooling
weird performance        performance comparable with Java
lisp                     curly braces

* Clojure is more adopted by teams that are already polyglot, service orientated, communicate mostly over HTTP
* Scala is adopted where binary artifacts are shared, codebases are big

### Tooling

* SBT slightly better than Leiningen 2
* Scala has good Eclipse and IntelliJ tooling, most of clojurians use Emacs

### Web development

* Clojure: ring middleware (abstracts out HTTP), Compojure -- very basic and low-level
* Scala: Lift, Scalatra, Play 2, ... -- rich, complete solutions

### Personal Experience

* Scala makes working on large Java codebase easier
* Knowing Clojure makes one a better Scala programmer

## Developing with F# in the Cloud

*Adam Granicz*

Sneak preview of CloudSharper -- not released yet -- online development environment for web and mobile applications.

* web-based IDE (looks like Visual Studio): multi=project solutions, on the fly type checking
* interactive window, can evaluate expressions and produce output such as interactive charts
* support for full F#
* advantage over Visual Studio: web-based no up-front cost (?), better for collaboration, position as a step beyond [Try F#](http://www.tryfsharp.org/)
* short demo video
* presentation unconvincing: why web-based platform makes it easier for teams to collaborate? What does it have to do with provisioning of hardware?
* overview of some F# features: units of measure, active patterns
* WebSharper is now open source

## Reducing Cognitive Bias in Design With Scala

*Paul Dale*

## LexiFi: Describing Financial Contracts and Extending OCaml

*Alain Frisch*

## F# in the Open Source World

*Don Syme*

## Functional Data Storage

*Greg Young*

## Pizza & Beer
