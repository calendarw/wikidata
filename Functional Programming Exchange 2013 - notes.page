* rrived at 9am, early enough to grab a seat at the front, next to power sockets -- front left.
* Met: Channing and Lance Walton, David Pollak, Adam Fisher

## Adventures with Types in Haskell

*Simon Peyton Jones*

* FPComplete School of haskell plug
* Reasons for Haskell popularity: purity, simple model (lambda calculus), **rich type system**
* Why we want types: catch certain classes of bugs, provide partial specification (e.g. `reverse :: [a] -> [a]`), express design, support interactive development (e.g. intellisense), **ease program maintenance** (e.g. pervasive changes in GHC, SPJ has confidence in making them because of type checks)
* look up: F# type providers, great example of how types help
* how types are bad: get in your way:

~~~ {.haskell}
data IntList = Nil | Cons Int IntList

lengthI :: IntList -> Int
~~~

now, what if we wanted to have length for list of chars? We need a more sophisticated type system (generics).

programs accepted by the language / programs that work -- we want as much overlap between these two sets as possible.

History:

* 1960s: Simple Types
* 1970s: ML with parametric polymorphism
* 1980s: plateau
* 1990s: Haskell: type classes, then plateau
* 2000s: GADTs, then plateau
* recent years: explosion of innovation, crazy type systems

SPJ will be saying a little about a lot of different type system features.

Plan for world domination: build on static typs so that mor good programs are accepted without killing the joy of programming

### Type classes

functions that are nearly polymorphic:

~~~ {.haskell}
sort :: [a] -> [a]
(+) :: a -> a -> a 
~~~

we don't want these functions to be baked into the runtime, specific for every type they operate on (that's what Java does). Solution: **type classes**,

~~~ {.haskell}
(+) :: Num a => a -> a -> a
~~~

### Higher kinds

~~~ {.haskell}
mapL :: (a -> b) -> [a] -> [b]
-- recursive
mapT :: (a -> b) -> Tree a -> Tree b
-- recursive
mapM :: (a -> b) -> Maybe a -> Maybe b
-- non-recursive
~~~

There is a commmon pattern here. How do we unify the API?

~~~ {.haskell}
class Functor k where
  fmap :: (a -> b) -> k a -> k b

instance Functor Maybe where
  fmap f x = mapM f x
~~~

Note: `k` ranges over not types, but type constructors; it has kind `* -> *` (anything of kind `* -> ...` is higher-kinded). This gives as access to whole new level of code reuse:

~~~ {.haskell}
sequence :: Monad m -> [m a] -> m [a]
~~~

This will work for anthing that is in `Monad` class.

Q: can type-level functions be written in ML?
A: using ML module syste to model higher-kinded types is like using a nuclear weapon to open a matchbox -- it works, but there is a lot of collateral damage.

Note: higher-kinded type variables are much harder in languages with subtyping (e.g. OO) because of _variance_.

GHC allows to specify kind signatures: `data Tree (x :: * -> *) (a :: *) = ...`.

Haskell attempts to reuse the intuitions from the term/type level one level up, with types/kinds -- e.g. querying for type (`:t`) and kind (`:k`) in GHCi.

Omega has infinite tower of universes (terms/types/kinds/sorts/level 5/level 6/...)

### GADTs

Idea: allow arbitrary return type for constructors, provided the outermost type constructor of type returned is still the type being defined.

~~~ {.haskell}
data Maybe a = Nothing | Just a
~~~

is the same as

~~~ {.haskell}
data Maybe a where
  Just :: a -> Maybe a
  Nothing :: Maube a
~~~

Classic example of usefulness: term evaluator (same as in [Advanced Haskell]()).

~~~ {.haskell}
data Term a where
  Lit :: Int - Term Int
  Succ :: Term Int -> Term Int
  IsZero :: Term Int -> Term Bool
~~~

Real-life story: stream-processing library Yampa needed to treat identity in a special way. Allowing to express that in type system made huge performance difference

### Type Functions

(a.k.a "type families")

~~~ {.haskell}
class Num a where
  (+) :: a -> a -> a
~~~

what if we want:

~~~ {.haskell}
class GNum a b where
  (+) :: a -> b -> ???

instance GNum Int Int where ...
instance GNum Int Float where ...
~~~

What do we put in place of `???`?

Given `a` and `b` we can tell what `???` should be. 

~~~ {.haskell}
class GNum a b where
  type SumTy a b :: * -- type-level function
  (+) :: a -> b -. SumTy a b

instance GNum Int Int where
  type SumTy Int Int = Int
  ...
~~~

### Kind polymorphism

No time to explain in detail.

~~~ {.haskell}
data T f a = MkT (f a)
~~~

f can be `* -> *` and a `*`
but it can also be `(* -> *) -> *` and `* -> *`

This is the same as `lengthInt` and `lengthChar` at the beginning. we want `T :: \forall k (k -> *) -> k -> *`

Ulitmate goal: **enable programmers to say what they mean**. Simple type systems really do get in our way. We need systems which are sophisticated enough to enable us to say what we mean while staying simple enough to be usable.

### Q/A

Q: Has every experiment that was added to Haskell stayed there?

A: In practice most of them stayed; there is one or two which proved wrong and were removed.

## Across Time and Address Space: Lift 3.0

*David Pollak*

## Reducing Cognitive Bias in Design With Scala

*Paul Dale*

## Comparing Scala and Clojure

*Robert Rees*

## Developing with F# in the Cloud

*Adam Granicz*

## Elnode: The Evented IO Web Server

*Nic Ferrier*

## LexiFi: Describing Financial Contracts and Extending OCaml

*Alain Frisch*

## F# in the Open Source World

*Don Syme*

## Functional Data Storage

*Greg Young*

## Pizza & Beer
