* rrived at 9am, early enough to grab a seat at the front, next to power sockets -- front left.
* Met: Channing and Lance Walton, David Pollak, Adam Fisher

## Adventures with Types in Haskell

*Simon Peyton Jones*

* FPComplete School of haskell plug
* Reasons for Haskell popularity: purity, simple model (lambda calculus), **rich type system**
* Why we want types: catch certain classes of bugs, provide partial specification (e.g. `reverse :: [a] -> [a]`), express design, support interactive development (e.g. intellisense), **ease program maintenance** (e.g. pervasive changes in GHC, SPJ has confidence in making them because of type checks)
* look up: F# type providers, great example of how types help
* how types are bad: get in your way:

~~~ {.haskell}
data IntList = Nil | Cons Int IntList

lengthI :: IntList -> Int
~~~

now, what if we wanted to have length for list of chars? We need a more sophisticated type system (generics).

programs accepted by the language / programs that work -- we want as much overlap between these two sets as possible.

History:

* 1960s: Simple Types
* 1970s: ML with parametric polymorphism
* 1980s: plateau
* 1990s: Haskell: type classes, then plateau
* 2000s: GADTs, then plateau
* recent years: explosion of innovation, crazy type systems

SPJ will be saying a little about a lot of different type system features.

Plan for world domination: build on static typs so that mor good programs are accepted without killing the joy of programming

### Type classes

functions that are nearly polymorphic:

~~~ {.haskell}
sort :: [a] -> [a]
(+) :: a -> a -> a 
~~~

we don't want these functions to be baked into the runtime, specific for every type they operate on (that's what Java does). Solution: **type classes**,

~~~ {.haskell}
(+) :: Num a => a -> a -> a
~~~

### Higher kinds

~~~ {.haskell}
mapL :: (a -> b) -> [a] -> [b]
-- recursive
mapT :: (a -> b) -> Tree a -> Tree b
-- recursive
mapM :: (a -> b) -> Maybe a -> Maybe b
-- non-recursive
~~~

There is a commmon pattern here. How do we unify the API?

~~~ {.haskell}
class Functor k where
  fmap :: (a -> b) -> k a -> k b

instance Functor Maybe where
  fmap f x = mapM f x
~~~

Note: `k` ranges over not types, but type constructors; it has kind `* -> *` (anything of kind `* -> ...` is higher-kinded). This gives as access to whole new level of code reuse:

~~~ {.haskell}
sequence :: Monad m -> [m a] -> m [a]
~~~

This will work for anthing that is in `Monad` class.

Q: can type-level functions be written in ML?
A: using ML module syste to model higher-kinded types is like using a nuclear weapon to open a matchbox -- it works, but there is a lot of collateral damage.

Note: higher-kkinded type variables are much harder in languages with subtyping (e.g. OO) because of _variance_.

GHC allows to specify kind signatures: `data Tree (x :: * -> *) (a :: *) = ...`.

Haskell attempts to reuse the intuitions from the term/type level one level up, with types/kinds -- e.g. querying for type (`:t`) and kind (`:k`) in GHCi.

Omega has infinite tower of universes (terms/types/kinds/sorts/level 5/level 6/...)

### GADTs

~~~ {.haskell}
data Maybe a = Nothing | Just a
~~~

is the same as

~~~ {.haskell}
data Maybe a where
  Just :: a -> Maybe a
  Nothing :: Maube a
~~~

Classic example of usefulness: term evaluator (same as in [Advanced Haskell]()).


## Across Time and Address Space: Lift 3.0

*David Pollak*

## Reducing Cognitive Bias in Design With Scala

*Paul Dale*

## Comparing Scala and Clojure

*Robert Rees*

## Developing with F# in the Cloud

*Adam Granicz*

## Elnode: The Evented IO Web Server

*Nic Ferrier*

## LexiFi: Describing Financial Contracts and Extending OCaml

*Alain Frisch*

## F# in the Open Source World

*Don Syme*

## Functional Data Storage

*Greg Young*

## Pizza & Beer
