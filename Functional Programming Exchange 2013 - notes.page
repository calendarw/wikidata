* rrived at 9am, early enough to grab a seat at the front, next to power sockets -- front left.
* Met: Channing and Lance Walton, David Pollak, Adam Fisher

## Adventures with Types in Haskell

*Simon Peyton Jones*

* FPComplete School of haskell plug
* Reasons for Haskell popularity: purity, simple model (lambda calculus), **rich type system**
* Why we want types: catch certain classes of bugs, provide partial specification (e.g. `reverse :: [a] -> [a]`), express design, support interactive development (e.g. intellisense), **ease program maintenance** (e.g. pervasive changes in GHC, SPJ has confidence in making them because of type checks)
* look up: F# type providers, great example of how types help
* how types are bad: get in your way:

~~~ {.haskell}
data IntList = Nil | Cons Int IntList

lengthI :: IntList -> Int
~~~

now, what if we wanted to have length for list of chars? We need a more sophisticated type system (generics).

programs accepted by the language / programs that work -- we want as much overlap between these two sets as possible.

History:

* 1960s: Simple Types
* 1970s: ML with parametric polymorphism
* 1980s: plateau
* 1990s: Haskell: type classes, then plateau
* 2000s: GADTs, then plateau
* recent years: explosion of innovation, crazy type systems

SPJ will be saying a little about a lot of different type system features.

Plan for world domination: build on static typs so that mor good programs are accepted without killing the joy of programming

### Type classes

functions that are nearly polymorphic:

~~~ {.haskell}
sort :: [a] -> [a]
(+) :: a -> a -> a 
~~~

we don't want these functions to be baked into the runtime, specific for every type they operate on (that's what Java does). Solution: **type classes**,

~~~ {.haskell}
(+) :: Num a => a -> a -> a
~~~

### Higher kinds

~~~ {.haskell}
mapL :: (a -> b) -> [a] -> [b]
-- recursive
mapT :: (a -> b) -> Tree a -> Tree b
-- recursive
mapM :: (a -> b) -> Maybe a -> Maybe b
-- non-recursive
~~~

There is a commmon pattern here. How do we unify the API?

~~~ {.haskell}
class Functor k where
  fmap :: (a -> b) -> k a -> k b

instance Functor Maybe where
  fmap f x = mapM f x
~~~

Note: `k` ranges over not types, but type constructors; it has kind `* -> *` (anything of kind `* -> ...` is higher-kinded). This gives as access to whole new level of code reuse:

~~~ {.haskell}
sequence :: Monad m -> [m a] -> m [a]
~~~

This will work for anthing that is in `Monad` class.

Q: can type-level functions be written in ML?
A: using ML module syste to model higher-kinded types is like using a nuclear weapon to open a matchbox -- it works, but there is a lot of collateral damage.

Note: higher-kinded type variables are much harder in languages with subtyping (e.g. OO) because of _variance_.

GHC allows to specify kind signatures: `data Tree (x :: * -> *) (a :: *) = ...`.

Haskell attempts to reuse the intuitions from the term/type level one level up, with types/kinds -- e.g. querying for type (`:t`) and kind (`:k`) in GHCi.

Omega has infinite tower of universes (terms/types/kinds/sorts/level 5/level 6/...)

### GADTs

Idea: allow arbitrary return type for constructors, provided the outermost type constructor of type returned is still the type being defined.

~~~ {.haskell}
data Maybe a = Nothing | Just a
~~~

is the same as

~~~ {.haskell}
data Maybe a where
  Just :: a -> Maybe a
  Nothing :: Maube a
~~~

Classic example of usefulness: term evaluator (same as in [Advanced Haskell]()).

~~~ {.haskell}
data Term a where
  Lit :: Int - Term Int
  Succ :: Term Int -> Term Int
  IsZero :: Term Int -> Term Bool
~~~

Real-life story: stream-processing library Yampa needed to treat identity in a special way. Allowing to express that in type system made huge performance difference

### Type Functions

(a.k.a "type families")

~~~ {.haskell}
class Num a where
  (+) :: a -> a -> a
~~~

what if we want:

~~~ {.haskell}
class GNum a b where
  (+) :: a -> b -> ???

instance GNum Int Int where ...
instance GNum Int Float where ...
~~~

What do we put in place of `???`?

Given `a` and `b` we can tell what `???` should be. 

~~~ {.haskell}
class GNum a b where
  type SumTy a b :: * -- type-level function
  (+) :: a -> b -. SumTy a b

instance GNum Int Int where
  type SumTy Int Int = Int
  ...
~~~

### Kind polymorphism

No time to explain in detail.

~~~ {.haskell}
data T f a = MkT (f a)
~~~

f can be `* -> *` and a `*`
but it can also be `(* -> *) -> *` and `* -> *`

This is the same as `lengthInt` and `lengthChar` at the beginning. we want `T :: \forall k (k -> *) -> k -> *`

Ulitmate goal: **enable programmers to say what they mean**. Simple type systems really do get in our way. We need systems which are sophisticated enough to enable us to say what we mean while staying simple enough to be usable.

### Q/A

Q: Has every experiment that was added to Haskell stayed there?

A: In practice most of them stayed; there is one or two (linear something?) which proved wrong and were removed.

## Across Time and Address Space: Lift 3.0

*David Pollak*

* Lift: developer centric/designer friendly
* most web frameworks are abstractions on top of HTTP request/response
* but developers think about putting buttons on pages, not HTTP
* interactivity is at the core: lift abstracts away the HTTP part of AJAX calls
* templating: DOM manipulation (functions `DOM => DOM`) instead of spitting out strings. This approach has later been used (cloned) in templating systems for Haskell, Java and JavaScript.
* designers and coders share the codebase; designers provide template, developers annotate them with `data-lift` transformations
* best Comet (server push) and Ajax support in the industry; client that disconnects and reconnects gets deltas (in order)
* current Comet implementation is over long polling, but it could be transparently ported to websockets
* automatic deduplication of Ajax requests (eg. on retry after timeout)
* seamless security
* DOM transformations can be done in parallel (e.g. when assembling parts of pages from different sources)
* asynchronous loading of page fragments
* 2.5 is about to be released, then 2.6
* 3.0 will be breaking
* goals for 3.0: move up market, down market, address time and space
* best futures in Scala-land -- EPFL's implementation is not always up to scratch (Q: is it still the case with Akka futures integrated into 2.10)
* markdown templating
* sources easier to understand for non-scala developers -- bindings can be in templates, not in scala sources
* seamless development cycle: changes in sources picked up dynamically, better than with JRebel, which barfs eg. when interface types of anonymous functions change
* server-side javascript data sources (controversial idea):

~~~ {.html}
  <li data-jssource="* *+ #> ['fpx, 2, 'dog', 'hi']">Thing: </li>
~~~

this will generate a list of four elements on the page.

## Reducing Cognitive Bias in Design With Scala

*Paul Dale*

## Comparing Scala and Clojure

*Robert Rees*

## Developing with F# in the Cloud

*Adam Granicz*

## Elnode: The Evented IO Web Server

*Nic Ferrier*

## LexiFi: Describing Financial Contracts and Extending OCaml

*Alain Frisch*

## F# in the Open Source World

*Don Syme*

## Functional Data Storage

*Greg Young*

## Pizza & Beer
